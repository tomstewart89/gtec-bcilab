#include "ovpCAlgorithmBrainampFileReader.h"

#include <system/ovCMemory.h>
#include <sstream>
#include <cstdlib>

#include <openvibe/ovITimeArithmetics.h>

using namespace OpenViBE;
using namespace OpenViBE::Kernel;
using namespace OpenViBE::Plugins;

using namespace OpenViBEPlugins;
using namespace OpenViBEPlugins::FileIO;

// using namespace std;

boolean CAlgorithmBrainampFileReader::initialize(void)
{
	ip_sFilename.initialize(getInputParameter(OVP_Algorithm_BrainampFileReader_InputParameterId_Filename));
	ip_f64EpochDuration.initialize(getInputParameter(OVP_Algorithm_BrainampFileReader_InputParameterId_EpochDuration));
	ip_ui64SeekTime.initialize(getInputParameter(OVP_Algorithm_BrainampFileReader_InputParameterId_SeekTime));
	ip_bConvertStimuli.initialize(getInputParameter(OVP_Algorithm_BrainampFileReader_InputParameterId_ConvertStimuli));

	op_ui64CurrentStartTime.initialize(getOutputParameter(OVP_Algorithm_BrainampFileReader_OutputParameterId_CurrentStartTime));
	op_ui64CurrentEndTime.initialize(getOutputParameter(OVP_Algorithm_BrainampFileReader_OutputParameterId_CurrentEndTime));
	op_ui64SamplingRate.initialize(getOutputParameter(OVP_Algorithm_BrainampFileReader_OutputParameterId_SamplingRate));
	op_pSignalMatrix.initialize(getOutputParameter(OVP_Algorithm_BrainampFileReader_OutputParameterId_SignalMatrix));
	op_pStimulations.initialize(getOutputParameter(OVP_Algorithm_BrainampFileReader_OutputParameterId_Stimulations));

	// Default value
	ip_bConvertStimuli = true;

	m_pBuffer=NULL;

	return true;
}

boolean CAlgorithmBrainampFileReader::uninitialize(void)
{
	if(m_oDataFile.is_open()) 
	{
		m_oDataFile.close();
	}

	op_pStimulations.uninitialize();
	op_pSignalMatrix.uninitialize();
	op_ui64SamplingRate.uninitialize();
	op_ui64CurrentEndTime.uninitialize();
	op_ui64CurrentStartTime.uninitialize();

	ip_bConvertStimuli.uninitialize();
	ip_ui64SeekTime.uninitialize();
	ip_f64EpochDuration.uninitialize();
	ip_sFilename.uninitialize();

	delete [] m_pBuffer;
	m_pBuffer=NULL;

	return true;
}

boolean CAlgorithmBrainampFileReader::process(void)
{
	if(this->isInputTriggerActive(OVP_Algorithm_BrainampFileReader_InputTriggerId_Open))
	{
		std::string l_sMarkerFilename;
		std::string l_sDataFilename;

		m_ui32BinaryFormat=BinaryFormat_Integer16;
		m_ui32ChannelCount=0;
		m_ui64StartSampleIndex=0;
		m_ui64EndSampleIndex=0;
		m_ui64SampleCountPerBuffer=0;
		m_vChannelScale.clear();
		delete [] m_pBuffer;
		m_pBuffer=NULL;
		m_ui32Endianness=Endianness_LittleEndian;

		m_oHeaderFile.open(ip_sFilename->toASCIIString(), std::ios::binary);
		if(!m_oHeaderFile.good())
		{
			getLogManager() << LogLevel_Error << "Could not open file [" << *ip_sFilename << "]\n";
			return false;
		}
		else
		{
			getLogManager() << LogLevel_Trace << "Opening " << *ip_sFilename << " succeeded\n";

			op_pSignalMatrix->setDimensionCount(2);

			uint32 l_ui32ChannelIndex=0;
			uint32 l_ui32Status=Status_Nothing;
			do
			{
				std::string l_sWhat;
				std::getline(m_oHeaderFile, l_sWhat, '\n');
				getLogManager() << LogLevel_Debug << CString(l_sWhat.c_str()) << "\n";

				// optionally removes ending carriage return for windows / linux compatibility
				if(l_sWhat.length()!=0)
				{
					if(l_sWhat[l_sWhat.length()-1]=='\r')
					{
						l_sWhat.erase(l_sWhat.length()-1, 1);
					}
				}

				if(l_sWhat.length()!=0)
				{
					std::string::size_type l_iEqualPosition;
					if(l_sWhat[0] == ';') // comments
					{
					}
					else if(l_sWhat.length() > 2 && l_sWhat[0]=='[') // section start
					{
						std::string l_sSectionName;
						l_sSectionName.assign(l_sWhat, 1, l_sWhat.length()-2);
						if(l_sSectionName=="Common Infos")
						{
							getLogManager() << LogLevel_Trace << "Found section " << CString(l_sWhat.c_str()) << "\n";
							l_ui32Status=Status_CommonInfos;
						}
						else if(l_sSectionName=="Binary Infos")
						{
							getLogManager() << LogLevel_Trace << "Found section " << CString(l_sWhat.c_str()) << "\n";
							l_ui32Status=Status_BinrayInfos;
						}
						else if(l_sSectionName=="Channel Infos")
						{
							getLogManager() << LogLevel_Trace << "Found section " << CString(l_sWhat.c_str()) << "\n";
							l_ui32Status=Status_ChannelInfos;
						}
						else if(l_sSectionName=="Comment")
						{
							getLogManager() << LogLevel_Trace << "Found section " << CString(l_sWhat.c_str()) << "\n";
							l_ui32Status=Status_Comment;
						}
						else
						{
							getLogManager() << LogLevel_Warning << "{" << CString(l_sWhat.c_str()) << "} looked like a new section in the header file but is not know of this parser. Therefore anything after this line will be skipped until a new section is found\n";
							l_ui32Status=Status_Nothing;
						}
					}
					else if((l_iEqualPosition=l_sWhat.find("="))!=std::string::npos && l_ui32Status!=Status_Comment) // Option value
					{
						std::string l_sOptionName;
						std::string l_sOptionValue;
						l_sOptionName.assign(l_sWhat, 0, l_iEqualPosition);
						l_sOptionValue.assign(l_sWhat, l_iEqualPosition+1, l_sWhat.length()-l_iEqualPosition-1);

						getLogManager() << LogLevel_Trace << "| Found option " << CString(l_sOptionName.c_str()) << " with value " << CString(l_sOptionValue.c_str()) << "\n";

						switch(l_ui32Status)
						{
							case Status_CommonInfos:
								if(l_sOptionName=="DataFormat")
								{
									if(l_sOptionValue!="BINARY")
									{
										getLogManager() << LogLevel_ImportantWarning << "Only binary data is supported\n";
									}
								}
								else if(l_sOptionName=="DataOrientation")
								{
									if(l_sOptionValue!="MULTIPLEXED")
									{
										getLogManager() << LogLevel_ImportantWarning << "Only multiplexed data is supported\n";
									}
								}
								else if(l_sOptionName=="DataType")
								{
									if(l_sOptionValue!="TIMEDOMAIN")
									{
										getLogManager() << LogLevel_ImportantWarning << "Only time domain data is supported\n";
									}
								}
								else if(l_sOptionName=="Codepage")
								{
									if(l_sOptionValue!="ANSI")
									{
										getLogManager() << LogLevel_Warning << "Header specifies code page as " << CString(l_sOptionValue.c_str()) << " but it will be forced back to " << CString("ANSI") << "\n";
									}
								}
								else if(l_sOptionName=="DataFile")
								{
									l_sDataFilename=l_sOptionValue;
								}
								else if(l_sOptionName=="MarkerFile")
								{
									l_sMarkerFilename=l_sOptionValue;
								}
								else if(l_sOptionName=="NumberOfChannels")
								{
									m_ui32ChannelCount=atoi(l_sOptionValue.c_str());
									m_vChannelScale.clear();
									m_vChannelScale.resize(m_ui32ChannelCount, 1);
									op_pSignalMatrix->setDimensionSize(0, m_ui32ChannelCount);
								}
								else if(l_sOptionName=="SamplingInterval")
								{
									float64 l_f64SamplingInterval=atof(l_sOptionValue.c_str());

									op_ui64SamplingRate=static_cast<uint64>(0.5+1000000.0/l_f64SamplingInterval);	// +0.5 for rounding

									m_ui64SampleCountPerBuffer=static_cast<int64>(ip_f64EpochDuration*op_ui64SamplingRate); // $$$ Casted in (int64) because of Ubuntu 7.10 crash !
									op_pSignalMatrix->setDimensionSize(1, static_cast<uint32>(m_ui64SampleCountPerBuffer));

									// TODO warn if approximated sampling rate
									getLogManager() << LogLevel_Trace << "| -> Calculated sampling frequency " << op_ui64SamplingRate << "Hz\n";
								}
								else
								{
									getLogManager() << LogLevel_Warning << "Skipped option " << CString(l_sOptionName.c_str()) << " with value " << CString(l_sOptionValue.c_str()) << "\n";
								}
								break;

							case Status_BinrayInfos:
								if(l_sOptionName=="BinaryFormat")
								{
									if(l_sOptionValue=="INT_16")
									{
										m_ui32BinaryFormat=BinaryFormat_Integer16;
									}
									else if(l_sOptionValue=="UINT_16")
									{
										m_ui32BinaryFormat=BinaryFormat_UnsignedInteger16;
									}
									else if(l_sOptionValue=="FLOAT_32" ||
											l_sOptionValue=="IEEE_FLOAT_32")
									{
										m_ui32BinaryFormat=BinaryFormat_Float32;
									}
									else
									{
										m_ui32BinaryFormat=BinaryFormat_Integer16;
										getLogManager() << LogLevel_ImportantWarning << "Unsupported binary format option value \"" << CString(l_sOptionValue.c_str()) << "\"... Switched back to 16 bits integer (default)\n";
									}
								}
								else if(l_sOptionName=="UseBigEndianOrder")
								{
									if(l_sOptionValue=="YES")
									{
										m_ui32Endianness=Endianness_BigEndian;
									}
									else if(l_sOptionValue=="NO")
									{
										m_ui32Endianness=Endianness_LittleEndian;
									}
									else
									{
										m_ui32Endianness=Endianness_LittleEndian;
										getLogManager() << LogLevel_ImportantWarning << "Unsupported use big endian order option value \"" << CString(l_sOptionValue.c_str()) << "\"... Switched back to little endian (default)\n";
									}
								}
								else
								{
									getLogManager() << LogLevel_Warning << "Skipped option " << CString(l_sOptionName.c_str()) << " with value " << CString(l_sOptionValue.c_str()) << "\n";
								}
								break;

							case Status_ChannelInfos:
								{
									std::stringstream l_sStringStream(l_sOptionValue);
									std::string l_sChannelName;
									std::string l_sReferenceChannelName;
									std::string l_sResolutionInUnit;
									std::string l_sUnitName;

									std::getline(l_sStringStream, l_sChannelName, ',');
									std::getline(l_sStringStream, l_sReferenceChannelName, ',');
									std::getline(l_sStringStream, l_sResolutionInUnit, ',');
									std::getline(l_sStringStream, l_sUnitName, ',');

									op_pSignalMatrix->setDimensionLabel(0, l_ui32ChannelIndex, l_sChannelName.c_str());
									m_vChannelScale[l_ui32ChannelIndex]=atof(l_sResolutionInUnit.c_str());
									l_ui32ChannelIndex++;
								}
								break;
						}
					}
				}
			}
			while(m_oHeaderFile.good());

			// Changing file location
			std::string l_sFullPath=ip_sFilename->toASCIIString();
			std::string l_sPath;
			std::string::size_type l_iSlashLocation=l_sFullPath.rfind("/");
			if(l_iSlashLocation!=std::string::npos)
			{
				l_sPath.assign(l_sFullPath, 0, l_iSlashLocation+1);
				l_sMarkerFilename=l_sPath+l_sMarkerFilename;
				l_sDataFilename=l_sPath+l_sDataFilename;
			}

			// Opens data file
			m_oDataFile.open(l_sDataFilename.c_str(), std::ios::binary);
			if(!m_oDataFile.good())
			{
				getLogManager() << LogLevel_Error << "Could not open file [" << CString(l_sDataFilename.c_str()) << "]\n";
			}
			else
			{
				getLogManager() << LogLevel_Trace << "Opening " << CString(l_sDataFilename.c_str()) << " succeeded\n";
			}

			// Opens marker file
			m_oMarkerFile.open(l_sMarkerFilename.c_str(), std::ios::binary);
			if(!m_oMarkerFile.good())
			{
				getLogManager() << LogLevel_Error << "Could not open file [" << CString(l_sMarkerFilename.c_str()) << "]\n";
			}
			else
			{
				getLogManager() << LogLevel_Trace << "Opening " << CString(l_sMarkerFilename.c_str()) << " succeeded\n";

				uint32 l_ui32Status=Status_Nothing;
				do
				{
					std::string l_sWhat;
					std::getline(m_oMarkerFile, l_sWhat, '\n');
					getLogManager() << LogLevel_Debug << CString(l_sWhat.c_str()) << "\n";

					// optionally removes ending carriage return for windows / linux compatibility
					if(l_sWhat.length()!=0)
					{
						if(l_sWhat[l_sWhat.length()-1]=='\r')
						{
							l_sWhat.erase(l_sWhat.length()-1, 1);
						}
					}

					if(l_sWhat.length()!=0)
					{
						std::string::size_type l_iEqualPosition;
						if(l_sWhat[0] == ';') // comments
						{
						}
						else if(l_sWhat.length() > 2 && l_sWhat[0]=='[') // section start
						{
							std::string l_sSectionName;
							l_sSectionName.assign(l_sWhat, 1, l_sWhat.length()-2);
							if(l_sSectionName=="Common Infos")
							{
								getLogManager() << LogLevel_Trace << "Found section " << CString(l_sWhat.c_str()) << "\n";
								l_ui32Status=Status_CommonInfos;
							}
							else if(l_sSectionName=="Marker Infos")
							{
								getLogManager() << LogLevel_Trace << "Found section " << CString(l_sWhat.c_str()) << "\n";
								l_ui32Status=Status_MarkerInfos;
							}
							else
							{
								getLogManager() << LogLevel_Warning << "{" << CString(l_sWhat.c_str()) << "} looked like a new section in the marker file but is not know of this parser. Therefore anything after this line will be skipped until a new section is found\n";
								l_ui32Status=Status_Nothing;
							}
						}
						else if((l_iEqualPosition=l_sWhat.find("="))!=std::string::npos && l_ui32Status!=Status_Comment) // Option value
						{
							std::string l_sOptionName;
							std::string l_sOptionValue;
							l_sOptionName.assign(l_sWhat, 0, l_iEqualPosition);
							l_sOptionValue.assign(l_sWhat, l_iEqualPosition+1, l_sWhat.length()-l_iEqualPosition-1);

							getLogManager() << LogLevel_Trace << "| Found option " << CString(l_sOptionName.c_str()) << " with value " << CString(l_sOptionValue.c_str()) << "\n";

							switch(l_ui32Status)
							{
								case Status_CommonInfos:
									break;

								case Status_MarkerInfos:
									{
										std::stringstream l_sStringStream(l_sOptionValue);
										std::string l_sMarkerType;
										std::string l_sMarkerDescription;
										std::string l_sMarkerPosition;
										std::string l_sMarkerDuration;
										std::string l_sMarkerChannelIndex;
										std::string l_sMarkerDate;

										std::getline(l_sStringStream, l_sMarkerType, ',');
										std::getline(l_sStringStream, l_sMarkerDescription, ',');
										std::getline(l_sStringStream, l_sMarkerPosition, ',');
										std::getline(l_sStringStream, l_sMarkerDuration, ',');
										std::getline(l_sStringStream, l_sMarkerChannelIndex, ',');
										std::getline(l_sStringStream, l_sMarkerDate, ',');

										getLogManager() << LogLevel_Trace << "| -> Found marker "
											<< CString(l_sMarkerType.c_str()) << ","
											<< CString(l_sMarkerDescription.c_str()) << ","
											<< CString(l_sMarkerPosition.c_str()) << ","
											<< CString(l_sMarkerDuration.c_str()) << ","
											<< CString(l_sMarkerChannelIndex.c_str()) << ","
											<< CString(l_sMarkerDate.c_str()) << "\n";

										if(l_sMarkerType=="Stimulus" && l_sMarkerDescription.length()>0)
										{
											if(l_sMarkerChannelIndex!="0")
											{
												getLogManager() << LogLevel_Warning << "Marker [" << CString(l_sMarkerType.c_str()) << ":" << CString(l_sMarkerDescription.c_str()) << "] is not marked on channel 0 and OpenViBE only supports global scope stimulations. Therefore this marker will be considered as global\n";
											}

											uint64 l_ui64Identifier;
											if(l_sMarkerDescription[0]=='S')
											{
												l_ui64Identifier = ::atoi(l_sMarkerDescription.substr(1, std::string::npos).c_str());
											} 
											else 
											{
												l_ui64Identifier = ::atoi(l_sMarkerDescription.c_str());
											}

											if(ip_bConvertStimuli) 
											{
												getLogManager() << LogLevel_Trace << "Pre-conversion stimulation is " << l_sMarkerDescription.c_str() << " at sample index [" << l_sMarkerPosition.c_str() << "]\n";
												l_ui64Identifier = OVTK_StimulationId_Label(l_ui64Identifier);
											}

											SStimulation l_oStimulation;
											l_oStimulation.m_ui64Identifier=l_ui64Identifier;
											l_oStimulation.m_ui64StartIndex=::atoi(l_sMarkerPosition.c_str());
											l_oStimulation.m_ui64Duration=::atoi(l_sMarkerDuration.c_str());
											l_oStimulation.m_sName=l_sMarkerDescription;
											m_vStimulation.push_back(l_oStimulation);

											getLogManager() << LogLevel_Trace << "Found stimulation " << l_oStimulation.m_ui64Identifier << " at sample index [" << l_oStimulation.m_ui64StartIndex << ":" << l_oStimulation.m_ui64Duration << "]\n";

										}
										else
										{
											getLogManager() << LogLevel_Warning << "Marker [" << CString(l_sMarkerType.c_str()) << ":" << CString(l_sMarkerDescription.c_str()) << "] is not supported. Therefore it will be ignored\n";
										}
									}
									break;
							}
						}
					}
				}
				while(m_oMarkerFile.good());
			}
		}
	}

	if(this->isInputTriggerActive(OVP_Algorithm_BrainampFileReader_InputTriggerId_Seek))
	{
		getLogManager() << LogLevel_ImportantWarning << "This has not been implemented yet\n";
	}

	if(this->isInputTriggerActive(OVP_Algorithm_BrainampFileReader_InputTriggerId_Next))
	{
		float64* l_pSignalMatrixBuffer=op_pSignalMatrix->getBuffer();

#define _do_it_with_type_(T) \
		{ \
			if(!m_pBuffer) \
			{ \
				m_pBuffer=new uint8[op_pSignalMatrix->getBufferElementCount()*sizeof(T)]; \
			} \
			uint8* l_pFileBuffer=m_pBuffer; \
			T l_tValue; \
			m_oDataFile.read((char*)l_pFileBuffer, op_pSignalMatrix->getBufferElementCount()*sizeof(T)); \
			if(m_oDataFile.eof()) \
			{ \
				System::Memory::set(l_pFileBuffer, op_pSignalMatrix->getBufferElementCount()*sizeof(T), 0); \
			} \
			boolean (*l_fpFileToHost)(const uint8*, T*); \
			if(m_ui32Endianness==Endianness_LittleEndian) \
			{ \
				l_fpFileToHost=System::Memory::littleEndianToHost; \
			} \
			else \
			{ \
				l_fpFileToHost=System::Memory::bigEndianToHost; \
			} \
			for(uint32 j=0; j<m_ui64SampleCountPerBuffer; j++) \
			{ \
				for(uint32 i=0; i<m_ui32ChannelCount; i++, l_pFileBuffer+=sizeof(T)) \
				{ \
					(*l_fpFileToHost)(l_pFileBuffer, &l_tValue); \
					l_pSignalMatrixBuffer[i*m_ui64SampleCountPerBuffer+j]=m_vChannelScale[i]*l_tValue; \
				} \
			} \
		}

		if(m_ui32BinaryFormat==BinaryFormat_Integer16)
		{
			_do_it_with_type_(int16);
		}
		if(m_ui32BinaryFormat==BinaryFormat_UnsignedInteger16)
		{
			_do_it_with_type_(uint16);
		}
		if(m_ui32BinaryFormat==BinaryFormat_Float32)
		{
			_do_it_with_type_(float32);
		}

		m_ui64StartSampleIndex=m_ui64EndSampleIndex;
		m_ui64EndSampleIndex+=m_ui64SampleCountPerBuffer;

		op_ui64CurrentStartTime=ITimeArithmetics::sampleCountToTime(op_ui64SamplingRate,m_ui64StartSampleIndex);
		op_ui64CurrentEndTime=ITimeArithmetics::sampleCountToTime(op_ui64SamplingRate,m_ui64EndSampleIndex);

		// find stimulations in this range
		uint64 l_ui64StimulationCount=0;
		std::vector < SStimulation >::const_iterator itStimulation;
		for(itStimulation=m_vStimulation.begin(); itStimulation!=m_vStimulation.end(); itStimulation++)
		{
			if(m_ui64StartSampleIndex <= itStimulation->m_ui64StartIndex && itStimulation->m_ui64StartIndex < m_ui64EndSampleIndex)
			{
				l_ui64StimulationCount++;
			}
		}

		op_pStimulations->setStimulationCount(l_ui64StimulationCount);
		l_ui64StimulationCount=0;
		for(itStimulation=m_vStimulation.begin(); itStimulation!=m_vStimulation.end(); itStimulation++)
		{
			if(m_ui64StartSampleIndex <= itStimulation->m_ui64StartIndex && itStimulation->m_ui64StartIndex < m_ui64EndSampleIndex)
			{
				uint64 l_ui64Date = ITimeArithmetics::sampleCountToTime(op_ui64SamplingRate,itStimulation->m_ui64StartIndex);
				uint64 l_ui64Duration = ITimeArithmetics::sampleCountToTime(op_ui64SamplingRate,itStimulation->m_ui64Duration);

				op_pStimulations->setStimulationIdentifier(l_ui64StimulationCount, itStimulation->m_ui64Identifier);
				op_pStimulations->setStimulationDate(l_ui64StimulationCount, l_ui64Date);
				op_pStimulations->setStimulationDuration(l_ui64StimulationCount, l_ui64Duration);
				l_ui64StimulationCount++;
			}
		}

		this->activateOutputTrigger(OVP_Algorithm_BrainampFileReader_OutputTriggerId_DataProduced, true);
	}

	if(this->isInputTriggerActive(OVP_Algorithm_BrainampFileReader_InputTriggerId_Close))
	{
		delete [] m_pBuffer;
		m_pBuffer=NULL;

		m_oMarkerFile.close();
		m_oDataFile.close();
		m_oHeaderFile.close();
	}

	return true;
}
